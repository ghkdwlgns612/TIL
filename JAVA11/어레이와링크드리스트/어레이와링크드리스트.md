## ArrayList와 LinkedList

###ArrayList란?
내부 저장소가 배열처럼 연속적인 메모리 형태를 가진 데이터 구조.

###LinkedList란?
각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어있는 방식의 데이터 구조.


이 부분은 저번에 자료구조를 공부하며 직접 구현해본 경험이 있다. 자료구조 중에서도 핵심적으로 이 둘의 차이는 알고가야한다고 생각한다. 왜냐하면 둘 중 무엇을 사용하느냐에 따라 성능이 확실하게 차이가나기 때문이다.
성능차이를 눈으로 확인해보자.

```
public class Main {
    public static void main(String[] args) {
        int N = 10000;
        ArrayList<String> arr1 = new ArrayList<>();
        LinkedList<String> arr2 = new LinkedList<>();

        for (int i = 0; i < N; i++) {
            arr1.add("String" + i);
            arr2.add("String" + i);
        }

        long startTime1 = System.nanoTime();
        arr1.get(5000);
        long endTime1 = System.nanoTime();
        System.out.println("ArrayList의 조회 : " + (endTime1-startTime1)); //7750

        long startTime2 = System.nanoTime();
        arr2.get(5000);
        long endTime2 = System.nanoTime();
        System.out.println("LinkedList의 조회 : " + (endTime2-startTime2)); //68208

    }
}
```

현재 같은 인덱스를 조회하는 상황이다. 걸리는 시간을 보면 거의 10배 가까이 차이가 난다. 그럼 중간에 데이터를 생성하면 어떻게 될까?
일정 숫자까지는 ArrayList가 LinkedList보다 제거 성능도 좋다. 그러나 숫자가 커지는 경우 조회 뿐만아니라 생성 및 수정성능도 LinkedList가 훨씬 좋아진다.

```

public class Main {
    public static void main(String[] args) {
        long N = 10000000;
        ArrayList<String> arr1 = new ArrayList<>();
        LinkedList<String> arr2 = new LinkedList<>();

        for (int i = 0; i < N; i++) {
            arr1.add("String" + i);
            arr2.add("String" + i);
        }

        long startTime1 = System.nanoTime();
        arr1.get(50);
        long endTime1 = System.nanoTime();
        System.out.println("ArrayList의 조회 : " + (endTime1-startTime1)); //15625

        long startTime2 = System.nanoTime();
        arr2.get(50);
        long endTime2 = System.nanoTime();
        System.out.println("LinkedList의 조회 : " + (endTime2-startTime2)); //8542


        long startTime3 = System.nanoTime();
        arr1.remove(500000);
        long endTime3 = System.nanoTime();
        System.out.println("ArrayList의 제거 : " + (endTime3-startTime3)); //6622375

        long startTime4 = System.nanoTime();
        arr2.remove(500000);
        long endTime4 = System.nanoTime();
        System.out.println("LinkedList의 제거 : " + (endTime4-startTime4)); //4018417

    }
}
```

이렇게 상황에 맞게 자료형을 사용하면 될 것 같다. 그럼 이제 어떻게 동작하는지 하나씩 뜯어보자.

### 1. ArrayList
ArrayList같은 경우는 동적으로 배열의 크기를 늘려가며 데이터를 받고 싶은 경우 사용합니다. 그러나 ArrayList도 마찬가지로 배열입니다.
내부적으로 배열의 크기를 초과하면 배열의 크기를 늘려가며 데이터를 받는 것입니다. 초기 값은 크기가 10인 배열의 크기입니다. 물론 new ArrayList(배열의크기)로 초기 배열크기를 지정해줄 수 있습니다. 그럼 add하면 어떤 동작을 하는지 살펴보겠습니다.
아래의 순서는 동작하는 순서대로 기록하겠습니다.

```
//add
public boolean add(E e) {
    modCount++;
    add(e, elementData, size);
    return true;
}

//add
private void add(E e, Object[] elementData, int s) {
    if (s == elementData.length)
        elementData = grow();
    elementData[s] = e;
    size = s + 1;
}

//grow
private Object[] grow() {
    return grow(size + 1);
}

//grow
private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData,
                                           newCapacity(minCapacity));
}

//newCapacity
private int newCapacity(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity <= 0) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            return Math.max(DEFAULT_CAPACITY, minCapacity); //DEFAULT_CAPACITY = 10
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return minCapacity;
    }
    return (newCapacity - MAX_ARRAY_SIZE <= 0) //Integer.MAX_VALUE - 8
        ? newCapacity
        : hugeCapacity(minCapacity);
}
```

위의 함수들을 적어보았습니다. Arrays.copyOf는 기존의 배열을 그대로 복사하는 함수입니다. copyOf까지 들어가면 너무 깊고 길어지기에 위의 동작까지만 살펴보겠습니다.
add를 하게되면 배열의 길이와 size를 확인하여 크기를 증가시킵니다. grow함수는 초기 크기가 10(1010)이면 10 + 5(0100) = 15로 증가시킵니다. 그리고 만약 arraySize가 (2147483647 - 8)보다 커지는 경우에는 hugeCapacity라는 함수가 실행됩니다.

다음으로 remove는 어떻게 동작하는지 살펴보자.

```
//remove
public E remove(int index) {
    Objects.checkIndex(index, size);
    final Object[] es = elementData;

    @SuppressWarnings("unchecked") E oldValue = (E) es[index];
    fastRemove(es, index);

    return oldValue;
}

//fastRemove
private void fastRemove(Object[] es, int i) {
        modCount++;
        final int newSize;
    if ((newSize = size - 1) > i)
        System.arraycopy(es, i + 1, es, i, newSize - i);
    es[size = newSize] = null;
}

//System.arraycopy
If the src and dest arguments refer to the same array object,
then the copying is performed as if the components at positions srcPos through srcPos+length-1 were first copied to a temporary array with length components and then the contents of the temporary array were copied into positions destPos through destPos+length-1 of the destination array.
```
checkIndex는 index가 size내부에 위치해있는지 확인하는 함수이다. 그리고 @SupperessWarnings는 컴파일 시 경고를 없애기 위해서 사용된다. 왜냐하면 사라진 값을 가지고 있기때문이다.
제일 중요한 fastRemove를 살펴보자. System.arraycopy의 동작은 i+1부터 끝까지 임시배열에 저장하고 그리고 임시 배열을 es의 i부터 끝까지 재배치 시킨다.



### 2. LinkedList