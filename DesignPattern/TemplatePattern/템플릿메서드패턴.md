## 템플릿 메서드 패턴에 대하여

템플릿 메서드의 핵심은 **변하지 않는 부분과 변하는 부분을 잘 분리하는 것**입니다.
변하는 것은 다형성(오버라이드)을 이용하여 구현하고 변하지 않는 것은 상속의 기능을 이용하면 됩니다.
예시를 살펴보겠습니다.

```
@Slf4j
public class TemplateMethod {

    public void run() {
        logic1();
        logic2();
    }

    private void logic1() {
        long startTime = System.currentTimeMillis();
        log.info("비즈니스 로직1 실행"); //변한다.
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }

    private void logic2() {
        long startTime = System.currentTimeMillis();
        log.info("비즈니스 로직2 실행"); //변한다.
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }
}
```
현재 겹치는 부분은 위의 주석에 표시해두었다. 이것을 분리해보자. 상속을 이용하여 변하지 않는 부분은 고정, 변하는 부분은 다형성으로 해결한다.

```
@Slf4j
public abstract class AbstractTemplate {

    public void execute() {
        long startTime = System.currentTimeMillis();
        //비즈니스 로직 실행
        call(); //상속
        //비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }

    protected abstract void call();
}
```

위의 클래스를 상속받으면 된다. 그리고 SubClassLogic1, SubClassLogic2 ...계속해서 늘려간다.
그러나 만약 클래스가 100개면? 계속 생성해야하나? 아니다. 익명 내부 클래스를 이용해 해결해보자.

```
static void test3() {
    AbstractTemplate template1 = new AbstractTemplate() {
        @Override
        protected void call() {
            log.info("비지니스 로직1 실행");
        }
    };
    AbstractTemplate template2 = new AbstractTemplate() {
        @Override
        protected void call() {
            log.info("비지니스 로직2 실행");
        }
    };
    log.info("클래스 이름1 = {}", template1.getClass());
    template1.execute();
    log.info("클래스 이름2 = {}", template2.getClass());
    template2.execute();
}
```

다음과 같이 해결하면 깔끔해진다. 새로운 클래스를 만들필요도 없어진다.
만약 변하지 않는 부분에서 변경이 일어나도 한 곳만 고쳐주면 해결이된다. 변경에 유연해지게 된다.
그러나 템플릿 메소드 패턴에는 큰 문제가 있다. 바로 **부모 클래스에 의존하고 있다는 것**이다.
이렇게 되면 쓰지도 않는 부모 메소드들이 변경되었을 때 사이드 이펙트가 발생할 수 있어 위험하다.
이러한 것을 보완한 패턴이 **전략 패턴**이다.

